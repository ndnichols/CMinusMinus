# Write Your Own Compile-to-JavaScript Language
or
# Revenge of the Stuff You Forgot from Your Compilers Course
Nate Nichols, Solutions Architect at Narrative Science

---

# Goals

* Get/keep you interested in Compile-to-JavaScript languages
* Convince you that there is no rocket science nor brain surgery involved

---

# Talk
* Motivation for Compile-to-JavaScript
* Overview of some big ones
* How they work
* C--
    * "The worst parts of C, running right in your browser!"Â®

---

> Sorry about "C2JS"

---

# What is a C2JS language? (See?)

A language that is not actually executed; the program is first *automatically converted(compiled)* to JavaScript, and that JavaScript is what's executed

---

# Everyone Is Working on C2JS Languages

* Google: Dart, AtScript, Closure
* Microsoft: TypeScript
* Facebook: JSX
* Mozilla: ASM.js, Sweet.js
* Miscellaneous: CoffeeScript, ClojureScript

---

# What's the point?

* If your application is written in JavaScript, it will run on every smart phone, tablet, and computer
* JavaScript has a lot of ~~problems~~ *opportunities*

---

# Two minutes of hate

```js
> '1' + 2
'12'
> '1' * 2
2
> +'1' + 2
3
> ['foo', 'bar', 'baz'].sort()
[ 'bar', 'baz', 'foo' ]
> [25, 1, 3].sort()
[ 1, 25, 3 ]

```
![right fit](nelson2.png)

---

> Come on guys, be cool. I did the whole thing in ten days.
-- Brendan Eich

---

# Dramatic tension for app developers!

* The JavaScript code that we write will run everywhere...
* We don't want to write JavaScript code

---

# Dramatic resolution for app developers!

* We'll write our code in "better" language X...
* We'll use the compiler for language X to convert it into JavaScript...
* That JavaScript code will run everywhere!

---

# Ultimate goal for app developers

* JavaScript becomes an implementation detail
    * Like ARM vs x86 is now
* Languages can continue to evolve while still running everywhere

---

# Aside: We've tried the other way

* Java Applets, ActiveX, and Flash were all attempts at another approach
* Adobe: "Rather than us compiling Flash to JavaScript, you should download this Flash runtime"

---

# Aside: We've tried the other way

* Adobe: "Rather than us translating Don Quixote to English, you should learn Medieval Spanish"


![inline 80%](20-do-not-want.jpg)

---

# Workflow

* Build tools are de rigueur
    * Gulp, Grunt
* "Edit file, save, see changes immediately" is achievable
* Popular languages have editor support

---

# Pain points

* Main issue: Debugging a JavaScript program when you wrote a CoffeeScript (or whatever) program
    * Main solution: Use a *Source Map*, which is metadata saying "This JS line was generated by this CoffeeScript line"
* Main solution effectiveness: Pretty solid
* Punchline: You still have to know JavaScript

---

> Let's look at a couple of ways that languages can be "better"

---

> CoffeeScript's Big Idea: Improved syntax leads to tighter, more expressive code with less boilerplate and fewer bugs.

---

# Tighter code


```coffee
# CoffeeScript
expensiveItems = _.filter items, (item) -> item.price > 1000
```

```js
// JavaScript
expensiveItems = _.filter(items, function(item) {
  return item.price > 1000;
});
```

---

# More expressive code

```coffee
# CoffeeScript
return unless entry?
```

```js
// JavaScript
if (typeof entry === "undefined" || entry === null) {
  return;
}
```

---

# Less boilerplate code

```coffee
# CoffeeScript
get "#{baseURL}/#{resource}?#{queryString}",
  timeout:10
  retries: 4
```

```js
// JavaScript
get("" + baseURL + "/" + resource + "?" + queryString, {
  timeout: 10,
  retries: 4
});
```

---

# Fewer bugs

```coffee
# CoffeeScript
->
  foo = 42
```

```js
// JavaScript
function() {
    // Foo correctly doesn't leak into global scope
    var foo;
    return foo = 42;
}
```

---

# CoffeeScript

* CoffeeScript keeps the JavaScript semantics.
    * Still loosely-typed, still dynamically-typed
* The conversion process is pretty straightforward, and you can feel what most of the compiler is doing
* "When I see a statement like `return x if y`, I will change that to `if (y) {return x;}`"

---

> TypeScript's Big Idea: You guys like C#, right? It's pretty good for stuff? Static typing and compile-time checks and all that? Yeah?

---

# TypeScript (optional) static typing

```js
// TypeScript
function greetUser(username: string) {
    alert("Hello, " + username);
}
greetUser({userName:'Guybrush'});
// COMPILE TIME ERROR!
```

```js
// JavaScript
function greetUser(username) {
    alert("Hello, " + username);
}
greetUser({username:'Guybrush'});
// Output: "Hello [object Object]"
// RUNTIME WEIRDNESS!
```

---

# TypeScript

* And all the other kinds of whizbangs you'd expect from C#/Java/etc
    * Generics, interfaces, modules, oh my!
* "JavaScript is fine for light scripting and UI geegaws. But today's big web applications need big enterprise-y languages."
    * "Plus, your .NET developers will be able to be effective straightaway"

---

![fit](zoidberg.png)
> AtScript's Big Idea: If you like TypeScript, but want to use a version from Google, why not AtScript?

---

# AtScript

* A lot like TypeScript
    * Better run-time type information
* AtScript is a superset of TypeScript is a superset of JavaScript
* Designed for Angular 2.0

---

> ClojureScript's Big Idea: Are you way into Clojure?

---

> Emscripten's Big Idea: There sure are a lot of C programs out there...

---

# Emscripten

* Compile programs written in C and C++ to a subset of JavaScript called *ASM.js*
* SQlite, Unreal Engine 3, VIM, PDF generation
* ASM.js is designed to be easy to optimize
    * Firefox special cases it for even more performance
    * ~ 1.5x slower than native
* Completely bananas

---

# So how do compilers all work?

---

# Algorithm

1. Parse C2JS source into representation of program **R<sub>C2JS</sub>**
1. Process that representation as desired **R<sub>C2JS</sub> -> R'<sub>C2JS</sub>**
1. Transform that representation into a representation of the JS program **R<sub>C2JS</sub>' -> R<sub>JS</sub>**
1. Output **R<sub>JS</sub>** as a .js source file

---

# Algorithm

```js
var cmmSource = readFile("input.cmm");
var cmmAST = parse(cmmSource);
cmmAST = process(cmmAST);
var jsAST = transform(cmm);
var jsSource = generateSource(jsAST);
writeFile(jsSource, "output.js");
```

---

# Parsing

* First task is to take in source and build structured representation of the source
    * Convert "1 + 2" to "Add two things, the left one is the integer 1 and the right one is the integer 2"
* Tons of jargon and details, but a simple idea at its core

---

# Goal

```js
var source = '1 + 2';
var ast = parse(source);
// ast is something like
// {
//     type: "BinaryExpression",
//     operator: "+"
//     left: {type: "Literal", value: 1},
//     right: {type: "Literal", value: 2}
// }
```
---

# Two steps of parsing

1. Use language rules to convert source string into list of tokens
    1. "Scanning", "lexing"
1. Use language rules to convert list of tokens into tree structure
    1. "Parsing"
1. You can see these steps being applied to JavaScript with [Esprima](http://esprima.org/demo/parse.html#)

---

# Parsing

1. Everybody does this
    1. Top-down, bottom-up, LR, LALR, blah blah
1. It's so common that folks have written programs for generating the parsers
    1. Lex/Yacc, Flex/Bison
1. Input: Token rules and parse rules. Output: Parser

---

# C--

```c
void swap(int *a, int *b) {
    int c = *b;
    *b = *a;
    *a = c;
}

int main()
{
  int big = 42;
  int small = 19;
  swap(&small, &big);
  printf("Big is %d and small is %d", big, small);
  return 0;
}
```

---

# Jison token rules

```ruby
[0-9]+("."[0-9]+)?\b  return 'NUMBER'
(int|float|void|char) return 'TYPE'
"return"              return 'RETURN'
".*?"                 return 'STRING'
\w+                   return 'VAR'
";"                   return 'SEMI'
"*"                   return 'STAR'
"="                   return 'EQUAL'
"("                   return 'LP'
...
```
---

# Jison parse rules

```ruby
statement
    : declaration EQUAL value SEMI
        { $$ = {"nodeType": "DeclarationAndAssignment", left: $1, right: $3};}
    | declaration SEMI
        { $$ = {nodeType: "DeclarationStatement", declaration:$1 };}
    | variable EQUAL value SEMI
        { $$ = {nodeType: "Assignment", left:$1 , right: $3};}
    ;
declaration
    : TYPE IDENTIFIER
        { $$ = {nodeType: "Declaration", type: $1, name: $2};}
    ;
```

---

# Processing in CMM

* We want to include static type-checking (like TypeScript and AtScript)


```c
int sum(int a, int b) {
    return a + b;
}

sum("Guybrush", 42);
// ERROR! Passing a string off as an int
```

---

# Processing pseudocode

1. For each node in the AST:
    1. If it's a variable declaration, record the name and type
    1. If it's a variable assignment, confirm the types match
    1. If it's a function declaration, record the name, type, and arguments
    1. If it's a function call, confirm the passed argument types match the function's parameters

---

# Transformation pseudocode

1. For each node in the .cmm AST:
    1. Convert from a .cmm representation to .js representation

```
{nodeType:"FunctionCall", name: "Foo"} ->
    {type: "CallExpression", callee: {type: "Identifier", name: "Foo"}}
```

---

# Generation pseudocode

1. For each node in the .js AST
    1. Build the source string representation for it
1. Stick all those strings together
1. (`escodegen` does all this for you)

---

# Generation

```js
generate({
"type": "ExpressionStatement",
"expression": {
    "type": "BinaryExpression",
    "operator": "+",
    "left": {
        "type": "Literal",
        "value": 1,
        "raw": "1"
    },
    "right": {
        "type": "Literal",
        "value": 2,
        "raw": "2"
    }
}); // -> '1 + 2'
```

---

# Demo

---

# Links

* https://github.com/ndnichols/CMinusMinus
* http://esprima.org/demo/parse.html

---

# Thanks and plug

Thanks!

## Narrative Science is hiring! Come help us build AI that makes people smarter

nnichols@narrativescience.com

